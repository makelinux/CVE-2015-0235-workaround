/* 
 * Modified GHOST with normal behaviour validation
 */

/*
 * GHOST vulnerability check
 * http://www.openwall.com/lists/oss-security/2015/01/27/9
 * Usage: gcc GHOST.c -o GHOST && ./GHOST
 */ 
 
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>

#define CANARY "in_the_coal_mine"

struct {
  char buffer[1024];
  char canary[sizeof(CANARY)];
} temp = { "buffer", CANARY };


int hostent_print(struct hostent *he)
{
	unsigned char *p = (unsigned char*)he->h_addr_list[0];
	return printf("type=%d len=%d addr=%u.%u.%u.%u 0x%08X\n", he->h_addrtype, he->h_length, p[0], p[1], p[2], p[3],*(int*)he->h_addr_list[0]);
}

int main(void) 
{
	struct hostent resbuf = {0,};
	struct hostent *result;
	int herrno;
	int retval;
	int af = 0;

	retval = gethostbyname_r("localhost", &resbuf, temp.buffer, sizeof(temp.buffer), &result, &herrno);
	if (result) {
		hostent_print(result);
		if (*(int*)result->h_addr_list[0] == 0x0100007F) {
			printf("original gethostbyname_r works\n");
		}
	} else
		exit(EXIT_FAILURE);

	result = NULL;
	retval = gethostbyname2_r("localhost", af, &resbuf, temp.buffer, sizeof(temp.buffer), &result, &herrno);
	if (result) {
		hostent_print(result);
		if (*(int*)result->h_addr_list[0] == 0x0100007F) {
			printf("original gethostbyname2_r works\n");
		}
	} else
		exit(EXIT_FAILURE);

	/*** strlen (name) = size_needed - sizeof (*host_addr) - sizeof (*h_addr_ptrs) - 1; ***/
	size_t len = sizeof(temp.buffer) - 16*sizeof(unsigned char) - 2*sizeof(char *) - 1;
	char name[sizeof(temp.buffer)];
	memset(name, '0', len);
	name[len] = '\0';

	retval = gethostbyname_r(name, &resbuf, temp.buffer, sizeof(temp.buffer), &result, &herrno);

	if (strcmp(temp.canary, CANARY) != 0) {
		puts("\033[2;31mvulnerable\033[0;39m");
		exit(EXIT_SUCCESS);
	}
	if (retval == ERANGE) {
		puts("not vulnerable");
		exit(EXIT_SUCCESS);
	}
	puts("should not happen");
	exit(EXIT_FAILURE);
}
