/*
 *	CVE-2015-0235-workaround
 *	shared library wrapper with additional check for vulnerable functions gethostbyname2_r gethostbyname_r
 *	Copyright (C) 2012 Constantine Shulyupin  http://www.makelinux.net/
 */

#include <stdlib.h>
#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <errno.h>
#include <dlfcn.h>

#ifdef verbose
#undef verbose
#define verbose(a...) fprintf(stderr,##a)
#else
#define verbose(a...) do {} while (0)
#endif

#define SPARE (sizeof(void*) * 8) /* actually even some spare bytes could be enough */

int (*gethostbyname_r_orig)(const char *name,
		struct hostent *ret, char *buf, size_t buflen,
		struct hostent **result, int *h_errnop);

int gethostbyname_r(const char *name,
		struct hostent *ret, char *buf, size_t buflen,
		struct hostent **result, int *h_errnop)
{
	verbose("%s %p\n", __func__, gethostbyname_r_orig);
	if (strlen(name) + SPARE > buflen) {
		fprintf(stderr,"%s name is too big, len=%zd\n",__func__, strlen(name));
		return ERANGE;
	}
	return gethostbyname_r_orig(name,ret,buf,buflen,result,h_errnop);
}

int (*gethostbyname2_r_orig)(const char *name, int af,
		struct hostent *ret, char *buf, size_t buflen,
		struct hostent **result, int *h_errnop);

int gethostbyname2_r(const char *name, int af,
		struct hostent *ret, char *buf, size_t buflen,
		struct hostent **result, int *h_errnop)
{
	verbose("%s %p\n",__func__, gethostbyname2_r_orig);
	if (strlen(name) + SPARE > buflen) {
		fprintf(stderr,"%s name is too big, len=%zd\n",__func__, strlen(name));
		return ERANGE;
	}
	return gethostbyname2_r_orig(name,af,ret,buf,buflen,result,h_errnop);
}

void *handle;

#define overload(f) f##_orig = dlsym(handle, #f);

__attribute__((constructor))
void __attribute__((constructor)) lib_init()
{
	verbose("%s, spare=%lu\n",__func__,SPARE);
	handle = dlopen ("libc.so.6", RTLD_LAZY);
	char *error;

	if (!handle) {
		fprintf(stderr,"%s\n",dlerror());
		exit(1);
	}

	overload(gethostbyname_r);
	overload(gethostbyname2_r);
	if ((error = dlerror()) != NULL)  {
		fprintf(stderr,"%s\n",error);
		exit(1);
	}
}

void __attribute__((destructor)) lib_end()
{
	verbose("%s\n",__func__);
	dlclose(handle);
}
